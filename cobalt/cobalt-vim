#!/usr/bin/env python
import json, collections, re, os.path, subprocess

gitPattern = '([^ /]+)/([^ /]+)'
gitPattern = re.compile(gitPattern)
cleanComment = re.compile('^\s*//.*$|^\s*$|^\s*#.*$', re.MULTILINE)

cobaltDir = "~/.vim/cobalt"
cobaltDir = os.path.expanduser(cobaltDir)

def testGit(x):
    try:
        return gitPattern.findall(x)[0]
    except:
        return False

def S(*args, **kwargs):
    with open(os.devnull, 'w') as devnull:
        cwd = kwargs.get('cwd', None)
        p = subprocess.Popen(args, cwd=cwd, stderr=devnull, stdout=subprocess.PIPE)
        out, err = p.communicate()
        return p.returncode, out

def gitAsyncClone(username, repo, path):
    url = 'https://github.com/%s/%s.git' % (username, repo)
    return subprocess.Popen(['git', 'clone', '--depth', '1', url, path],
            stderr=subprocess.PIPE,
            stdout=subprocess.PIPE)

def gitClone(username, repo, path):
    url = 'https://github.com/%s/%s.git' % (username, repo)
    # subprocess.Popen(['git', 'clone', '--depth', '1', url, path])
    code, _ = S('git', 'clone', '--depth', '1', url, path)
    return code == 0

def gitTagAndRevision(path):
    _, tag = S('git', 'describe', '--tags', cwd=path)
    _, revision = S('git', 'rev-parse', 'HEAD', cwd=path)
    if tag:
        return (tag.strip(), revision.strip())
    return (None, revision.strip())

def gitUsernameAndRepo(path):
    _, url = S('git', 'remote', '-v', cwd=path)
    url = url.replace('github.com/', '')
    username, repo = testGit(url)
    return username, repo.replace('.git', '')

def getPath(info):
    if info['type'] == 'git':
        return '%s/%s.%s' % (cobaltDir, info['username'], info['repo'])
    return None

def detectType(x):
    try:
        username, repo = gitPattern.findall(x)[0]
        return {
                'type': 'git',
                'username': username,
                'repo': repo
                }
    except:
        return False

def mkdir_p(path):
    try:
        os.makedirs(path)
        return True
    except:
        return False

def installed():
    return os.listdir(cobaltDir)

def loadLock(path):
    try:
        with open(path) as file:
            return json.load(file)
    except:
        return {}

def loadPlugins(path):
    with open(path) as file:
        data = file.read()
        data = cleanComment.sub('', data)
        return json.loads(data, object_pairs_hook=collections.OrderedDict)

class dotdict(dict):
    """dot.notation access to dictionary attributes"""
    def __getattr__(self, attr):
        return self.get(attr)
    __setattr__= dict.__setitem__
    __delattr__= dict.__delitem__

mkdir_p(cobaltDir)

plugins = loadPlugins('plugins.json')
installed = loadLock('cobalt.vimlock')
seen = {}

async = {}

for plugin, options in plugins.items():
    result = detectType(plugin)
    if not result:
        raise Exception('Error: unknown format "%s"' % (plugin,))
    path = getPath(result)
    if not path:
        raise Exception('Error: "%s" schema is currenlty unimplemented' % (result['type'],))

    if plugin in installed:
        path = installed[plugin].get('path', path)
        # path = options.get('path', path)
        if not os.path.exists(path):
            print "\033[90m%s:\033[0m Error in cobalt.vimlock, reinstalling" % (plugin,)
            username, repo = result['username'], result['repo']
            info = installed[plugin]
            info['pipe'] = gitAsyncClone(username, repo, path)
            info['options'] = options
            async[plugin] = info
            continue
        print "\033[90m%s:\033[0m Already installed" % (plugin,)
        seen[plugin] = installed[plugin]
    else:
        if os.path.exists(path + '~'):
            print "\033[92m%s:\033[0m Restoring previous installation." % (plugin,)
            os.rename(path + '~', path)
            username, repo = gitUsernameAndRepo(path)
            tag, revision = gitTagAndRevision(path)
            seen[plugin] = {
                    'path': path,
                    'username': username,
                    'repo': repo,
                    'revision': revision,
                    'tag': tag
                    }
            continue
        # result = dotdict(detectType(plugin))
        if os.path.exists(path):
            print "\033[90m%s:\033[0m Already installed. Data corrupted. Fixing." % (plugin,)
            username, repo = gitUsernameAndRepo(path)
            tag, revision = gitTagAndRevision(path)
            seen[plugin] = {
                    'path': path,
                    'username': username,
                    'repo': repo,
                    'revision': revision,
                    'tag': tag
                    }
            continue
        if result['type'] == 'git':
            username, repo = result['username'], result['repo']
            p = gitAsyncClone(username, repo, path)
            async[plugin] = {
                    'pipe': p,
                    'path': path,
                    'username': username,
                    'repo': repo
                    }
            continue

for plugin, info in async.items():
    p = info['pipe']
    p.wait()
    if p.returncode == 0:
        username, repo, path = info['username'], info['repo'], info['path']
        print "\033[90m%s\033[0m/\033[93m%s:\033[0m Installed to %s" % (username, repo, path)
        tag, revision = gitTagAndRevision(path)
        del info['pipe']
        info['revision'] = revision
        info['tag'] = tag
        options = info['options']
        subprocess.call(options['postinstall'], shell=True)
        seen[plugin] = info
    else:
        out, err = p.communicate()
        print "\033[90mError:\033[0m Failed to install '%s': \033[93m'%s'\033[0m" % (plugin, out + err)

removed = set(installed.keys()) - set(seen.keys())
for plugin in removed:
    info = installed[plugin]
    path = info['path']
    try:
        if os.path.exists(path):
            print "\033[91m%s:\033[0m Removed, hiding from pathogen." % (plugin,)
            os.rename(path, path + '~')
        else:
            print "\033[91m%s:\033[0m Removed, but path not found anyway." % (plugin,)
        # elif os.path.exists(path + '~'):
        #     pass
    except Exception as e:
        print "Uncaught exception: " + str(e)

with open('cobalt.vimlock', 'w') as file:
    json.dump(seen, file)

